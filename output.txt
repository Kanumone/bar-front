// === ./src/2048/components/field/index.ts ===
export * from "./field";



// === ./src/2048/components/score/index.ts ===
export * from "./score";



// === ./src/2048/hooks/index.ts ===
export * from "./use-game";

export * from "./use-game-over";

export * from "./use-game-actions";

export * from "./use-field";

export * from "./use-score";



// === ./src/vite-env.d.ts ===
/// <reference types="vite/client" />
/// <reference types="./telegram.d.ts" />



// === ./src/2048/components/field/field.tsx ===
import { useCallback, useMemo } from "react";

import styles from "./field.module.css";
import { AnimatePresence, motion } from "motion/react";
import { useField } from "../../hooks";
import { useGameInput } from "../../hooks/use-game-input";

export function Field() {
  const field = useField();
  useGameInput();

  const itemStyleMap: Record<number, string> = useMemo(() => ({
    2: styles.item2,
    4: styles.item4,
    8: styles.item8,
    16: styles.item16,
    32: styles.item32,
    64: styles.item64,
    128: styles.item128,
    256: styles.item256,
    512: styles.item512,
    1024: styles.item1024,
    2048: styles.item2048,
  }), []);

  const getItemStyle = useCallback((val: number) => {
    return itemStyleMap[val] || styles.item;
  }, [itemStyleMap]);

  return (
    <div className={styles.field}>
      <AnimatePresence mode="popLayout">
        {field?.map((row) =>
          row.map(({ value, key }) => (
            <motion.div
              key={key}
              layout
              initial={{ scale: 0.8, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              exit={{ scale: 0.8, opacity: 0 }}
              transition={{
                type: "spring",
                stiffness: 500,
                damping: 20,
                duration: 0.4,
              }}
              className={[styles.item, getItemStyle(value)].join(" ")}
            >
              {value || ""}
            </motion.div>
          )),
        )}
      </AnimatePresence>
    </div>
  );
}



// === ./src/2048/components/game-content.tsx ===
import { Field } from "./field";
import { useScore, useGameOver, useGameActions } from "../hooks";
import { Score } from "./score";
import styles from "./app.module.css";

export function GameContent() {
  const { score, highScore } = useScore();
  const over = useGameOver();
  const { restart } = useGameActions();

  return (
    <div className={styles.gameContainer}>
      <h1 className={styles.title}>2048</h1>
      <button onClick={restart}>restart</button>
      <h2 className={over ? styles.gameOver : styles.game}>Game Over</h2>
      <Score score={score} highscore={highScore}/>
      <Field />
    </div>
  );
}



// === ./src/2048/components/score/score.tsx ===
import styles from "./score.module.css";

export const Score = ({ score, highscore }: { score: number, highscore: number }) => {

  return (
    <div className={styles.scoreContainer}>
      <span className={styles.score}>score: {score}</span>
      <span className={styles.score}>best: {highscore}</span>
    </div>

  );
};




// === ./src/2048/context/game-context.tsx ===
import { createContext } from "react";
import type { GameInterface } from "../provider/game-provider";

export const GameContext = createContext<GameInterface | undefined>(undefined);



// === ./src/2048/hooks/use-field.tsx ===
import { useGame } from "./use-game";

export const useField = () => {
  const { gameState } = useGame();
  return gameState.field;
};



// === ./src/2048/hooks/use-game-actions.tsx ===
import { useCallback } from "react";
import { useGame } from "./use-game";

export const useGameActions = () => {
  const { game } = useGame();
  return {
    moveLeft: useCallback(() => game.moveLeft(), [game]),
    moveRight: useCallback(() => game.moveRight(), [game]),
    moveUp: useCallback(() => game.moveUp(), [game]),
    moveDown: useCallback(() => game.moveDown(), [game]),
    restart: useCallback(() => game.restart(), [game]),
  };
};



// === ./src/2048/hooks/use-game-input.tsx ===
// src/2048/hooks/use-game-input.ts
import { useEffect } from "react";
import { useGameActions } from "./use-game-actions"; // Предполагаем, что useGameActions находится рядом

export const useGameInput = () => {
  const { moveLeft, moveRight, moveUp, moveDown } = useGameActions();

  useEffect(() => {
    // --- Обработка клавиатуры ---
    const keyListener = (e: KeyboardEvent) => {
      switch (e.key) {
      case "ArrowLeft":
        moveLeft();
        break;
      case "ArrowRight":
        moveRight();
        break;
      case "ArrowUp":
        moveUp();
        break;
      case "ArrowDown":
        moveDown();
        break;
      default:
        return;
      }
    };

    document.addEventListener("keydown", keyListener);

    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;

    const handleTouchStart = (e: TouchEvent) => {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    };

    const handleTouchEnd = (e: TouchEvent) => {
      touchEndX = e.changedTouches[0].clientX;
      touchEndY = e.changedTouches[0].clientY;

      const dx = touchEndX - touchStartX;
      const dy = touchEndY - touchStartY;

      const minSwipeDistance = 30;

      if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > minSwipeDistance) {

        if (dx > 0) {
          moveRight();
        } else {
          moveLeft();
        }
      } else if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > minSwipeDistance) {
        if (dy > 0) {
          moveDown();
        } else {
          moveUp();
        }
      }
    };

    document.addEventListener("touchstart", handleTouchStart, { passive: true });
    document.addEventListener("touchend", handleTouchEnd, { passive: true });

    return () => {
      document.removeEventListener("keydown", keyListener);
      document.removeEventListener("touchstart", handleTouchStart);
      document.removeEventListener("touchend", handleTouchEnd);
    };
  }, [moveLeft, moveRight, moveUp, moveDown]);
};



// === ./src/2048/hooks/use-game-over.tsx ===
import { useGame } from "./use-game";

export const useGameOver = () => {
  const { gameState } = useGame();
  return gameState.over;
};



// === ./src/2048/hooks/use-game.tsx ===
import { use, useEffect, useState } from "react";
import { type GameState } from "../provider/game-provider";
import { GameContext } from "../context/game-context";

export const useGame = () => {
  const game = use(GameContext);
  if (game === undefined) {
    throw new Error("useGame must be used within a GameProvider");
  }

  // Используем глубокую копию состояния, чтобы React видел изменения вложенных объектов
  const [gameState, setGameState] = useState<GameState>(() => ({
    ...game.state,
    field: game.state.field.map((row) => row.map((item) => ({ ...item }))),
  }));

  useEffect(() => {
    const listener = (state: GameState) => {
      // Обновляем состояние React при изменении состояния игры
      setGameState(state);
    };

    game.subscribe(listener);

    return () => {
      game.unsubscribe(listener);
    };
  }, [game]); // 'game' - единственная зависимость, она не меняется после первого рендера

  return { game, gameState };
};



// === ./src/2048/hooks/use-score.tsx ===
import { useGame } from "./use-game";

export const useScore = () => {
  const { gameState } = useGame();
  return { score: gameState.score, highScore: gameState.highScore };
};



// === ./src/2048/main.tsx ===
import { GameProvider } from "./provider/game-provider";
import { GameContent } from "./components/game-content";

export function Game2048() {
  return (
    <GameProvider>
      <GameContent />
    </GameProvider>
  );
}



// === ./src/2048/provider/game-provider.tsx ===
// === src/gameContext.ts ===

import { useRef, type PropsWithChildren } from "react";
import { GameContext } from "../context/game-context";

// Константа для размера сетки
const GRID_SIZE = 4;

// Интерфейсы (можно импортировать из logic.ts, если вы хотите их там оставить)
export interface GameInterface {
  state: GameState;
  moveLeft(): void;
  moveRight(): void;
  moveUp(): void;
  moveDown(): void;
  restart(): void;
  spawn(): void;
  subscribe(callback: (state: GameState) => void): void;
  unsubscribe(callback: (state: GameState) => void): void;
}

export interface GameState {
  highScore: number;
  score: number;
  level?: number;
  field: FieldItem[][];
  over: boolean;
  won?: boolean;
}

export interface FieldItem {
  value: number;
  key: string;
}

const defaultState: GameState = {
  highScore: 0,
  score: 0,
  field: [],
  over: false,
  won: false,
};

class Game implements GameInterface {
  state: GameState = { ...defaultState };
  subscribers = new Set<(state: GameState) => void>();
  idKey = 0;

  constructor() {
    this.init(); // Инициализирует состояние из defaultState (highScore: 0)
    // Загружаем highScore из localStorage только после инициализации defaultState
    const storedHighScore = Number(localStorage.getItem("highScore"));
    if (!isNaN(storedHighScore) && storedHighScore > 0) {
      this.state.highScore = storedHighScore; // Устанавливаем загруженное значение
    }
  }

  init() {
    // При рестарте или инициализации сбрасываем счет и поле, но сохраняем лучший результат
    this.state = {
      ...defaultState,
      highScore: this.state.highScore, // Сохраняем текущий highScore
    };
    this.state.field = this.generateField();
  }

  subscribe(callback: (state: GameState) => void) {
    this.subscribers.add(callback);
  }

  unsubscribe(callback: (state: GameState) => void): void {
    this.subscribers.delete(callback);
  }

  on() {
    // Уведомляем всех подписчиков о новом состоянии (создаем новую копию, чтобы React видел изменения)
    this.subscribers.forEach((callback) => callback({ ...this.state, field: this.deepCopyField(this.state.field) }));
  }

  spawn(): void {
    const emptyCells: { row: number; col: number }[] = [];

    for (let i = 0; i < GRID_SIZE; i++) {
      for (let j = 0; j < GRID_SIZE; j++) {
        if (this.state.field[i][j].value === 0) {
          emptyCells.push({ row: i, col: j });
        }
      }
    }

    if (emptyCells.length === 0) {
      this.state.over = true;
    } else {
      const { row, col } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
      this.state.field[row][col] = { value: Math.floor(Math.random() > 0.5 ? 4 : 2), key: this.generateUniqueKey() }; // Создаем новый объект FieldItem
    }
    this.on();
  }

  // Вспомогательная функция для обработки строк/столбцов
  private processRow(row: FieldItem[]): { newRow: FieldItem[], scoreIncrease: number } { // 'newScore' удален, т.к. не использовался
    const filteredRow = row.filter(({ value }) => value !== 0);
    const mergedRow: FieldItem[] = [];
    let scoreIncrease = 0;
    let j = 0;

    while (j < filteredRow.length) {
      if (j + 1 < filteredRow.length && filteredRow[j].value === filteredRow[j + 1].value) {
        const newValue = filteredRow[j].value * 2;
        mergedRow.push({ value: newValue, key: this.generateUniqueKey() }); // Создаем новый объект для слитой ячейки
        scoreIncrease += newValue;
        j += 2;
      } else {
        mergedRow.push({ ...filteredRow[j] }); // Копируем существующий объект
        j += 1;
      }
    }

    while (mergedRow.length < GRID_SIZE) {
      mergedRow.push({ value: 0, key: this.generateUniqueKey() }); // Добавляем пустые ячейки с новыми ключами
    }
    return { newRow: mergedRow, scoreIncrease };
  }

  moveLeft(): void {
    const originalField = this.deepCopyField(this.state.field);
    let newScore = this.state.score;
    const newField: FieldItem[][] = originalField.map(() => []); // Создаем новую структуру поля

    for (let i = 0; i < GRID_SIZE; i++) {
      const { newRow, scoreIncrease } = this.processRow(originalField[i]); // 'newScore' удален
      newField[i] = newRow;
      newScore += scoreIncrease;
    }

    const changed = !this.areArraysEqual(newField, originalField);
    if (changed) {
      this.state.field = newField;
      this.state.score = newScore;
      this.spawn();
    }
    const shouldNotify = this.checkIsOver() || changed;
    if (shouldNotify) {
      this.on();
    }
  }

  moveRight(): void {
    const originalField = this.deepCopyField(this.state.field);
    let newScore = this.state.score;
    const newField: FieldItem[][] = originalField.map(() => []);

    for (let i = 0; i < GRID_SIZE; i++) {
      const reversedRow = [...originalField[i]].reverse();
      const { newRow, scoreIncrease } = this.processRow(reversedRow); // 'newScore' удален
      newField[i] = newRow.reverse(); // Возвращаем в правильном порядке
      newScore += scoreIncrease;
    }

    const changed = !this.areArraysEqual(newField, originalField);
    if (changed) {
      this.state.field = newField;
      this.state.score = newScore;
      this.spawn();
    }
    const shouldNotify = this.checkIsOver() || changed;
    if (shouldNotify) {
      this.on();
    }
  }

  moveUp(): void {
    const originalField = this.deepCopyField(this.state.field);
    let newScore = this.state.score;
    const transposed = this.transpose(originalField);
    const newTransposed: FieldItem[][] = transposed.map(() => []);

    for (let i = 0; i < GRID_SIZE; i++) {
      const { newRow, scoreIncrease } = this.processRow(transposed[i]); // 'newScore' удален
      newTransposed[i] = newRow;
      newScore += scoreIncrease;
    }

    const newField = this.transpose(newTransposed); // Обратное транспонирование
    const changed = !this.areArraysEqual(newField, originalField);
    if (changed) {
      this.state.field = newField;
      this.state.score = newScore;
      this.spawn();
    }
    const shouldNotify = this.checkIsOver() || changed;
    if (shouldNotify) {
      this.on();
    }
  }

  moveDown(): void {
    const originalField = this.deepCopyField(this.state.field);
    let newScore = this.state.score;
    const transposed = this.transpose(originalField);
    const newTransposed: FieldItem[][] = transposed.map(() => []);

    for (let i = 0; i < GRID_SIZE; i++) {
      const reversedCol = [...transposed[i]].reverse();
      const { newRow, scoreIncrease } = this.processRow(reversedCol); // 'newScore' удален
      newTransposed[i] = newRow.reverse(); // Возвращаем в правильном порядке
      newScore += scoreIncrease;
    }

    const newField = this.transpose(newTransposed);
    const changed = !this.areArraysEqual(newField, originalField);
    if (changed) {
      this.state.field = newField;
      this.state.score = newScore;
      this.spawn();
    }
    const shouldNotify = this.checkIsOver() || changed;
    if (shouldNotify) {
      this.on();
    }
  }

  private checkScore(): void {
    if (this.state.score > this.state.highScore) {
      this.state.highScore = this.state.score;
      localStorage.setItem("highScore", String(this.state.highScore)); // Прямой вызов, без Promise
    }
  }

  private checkIsOver(): boolean {
    this.checkScore();

    // Если есть нулевые ячейки — игра не окончена
    for (let i = 0; i < GRID_SIZE; i++) {
      for (let j = 0; j < GRID_SIZE; j++) {
        if (this.state.field[i][j].value === 0) {
          this.state.over = false;
          return this.state.over;
        }
      }
    }

    // Проверяем соседние ячейки на возможность слияния (горизонтально)
    for (let i = 0; i < GRID_SIZE; i++) {
      for (let j = 0; j < GRID_SIZE - 1; j++) {
        if (this.state.field[i][j].value === this.state.field[i][j + 1].value) {
          this.state.over = false;
          return this.state.over;
        }
      }
    }

    // Проверяем соседние ячейки на возможность слияния (вертикально)
    for (let j = 0; j < GRID_SIZE; j++) {
      for (let i = 0; i < GRID_SIZE - 1; i++) {
        if (this.state.field[i][j].value === this.state.field[i + 1][j].value) {
          this.state.over = false;
          return this.state.over;
        }
      }
    }

    this.state.over = true;
    return this.state.over;
  }

  restart(): void {
    this.init();
    this.spawn();
    this.spawn();
    this.on(); // Уведомляем UI о новом состоянии игры
  }

  private transpose<T>(matrix: T[][]): T[][] {
    if (matrix.length === 0 || matrix[0].length === 0) return [];
    return matrix[0].map((_, colIndex) => matrix.map((row) => row[colIndex]));
  }

  private generateField(): FieldItem[][] {
    return Array.from({ length: GRID_SIZE }, () =>
      Array.from({ length: GRID_SIZE }, () => ({ value: 0, key: this.generateUniqueKey() })),
    );
  }

  private areArraysEqual(a: FieldItem[][], b: FieldItem[][]): boolean {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (a[i].length !== b[i].length) return false;
      for (let j = 0; j < a[i].length; j++) {
        // Сравниваем только value, ключи могут отличаться, если это новые объекты
        if (a[i][j].value !== b[i][j].value) return false;
      }
    }
    return true;
  }

  private deepCopyField(field: FieldItem[][]): FieldItem[][] {
    return field.map((row) => row.map((item) => ({ ...item })));
  }

  generateUniqueKey(): string {
    this.idKey += 1;
    return String(this.idKey);
  }
}

export const GameProvider = ({ children }: PropsWithChildren) => {
  const gameRef = useRef<GameInterface | null>(null);

  if (!gameRef.current) {
    gameRef.current = new Game();
    // Инициализация игры при первом создании экземпляра
    gameRef.current.spawn();
    gameRef.current.spawn();
  }

  return (
    <GameContext value={gameRef.current}>
      {children}
    </GameContext>
  );
};



// === ./src/app.tsx ===
import { Game2048 } from "./2048/main";

export const App = () => {
  return (
    <Game2048/>
  );
};



// === ./src/main.tsx ===
import { createRoot } from "react-dom/client";
import { App } from "./app";
import React from "react";

const root = document.body.querySelector("#root");
if (!root) {
  throw new Error("Root element not found");
}

createRoot(root).render(
  <React.StrictMode>
    <App/>
  </React.StrictMode>,
);



// === ./src/2048/components/app.module.css ===
.gameContainer {
  margin: 0 auto;
  display: flex;
  flex-direction: column;
  align-items: center;
  border: 1px solid black;
  border-radius: 5px;
  max-width: 600px;
  padding: 40px;
}

.title {
  font-size: 40px;
}

.game {
  opacity: 0;
}

.gameOver {
  opacity: 1;
  transition: opacity 0.5s ease-in-out;
  color: red;
  font-size: 2rem;
  text-align: center;
  margin: 10px auto;
}


// === ./src/2048/components/field/field.module.css ===
.field {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(4, 1fr);
  width: 100%;
  aspect-ratio: 1 / 1;
  border-radius: 5px;
  background-color: #bbada0;
  place-content: space-evenly space-evenly;
  padding: 10px;
  gap: 10px;
  container: field / size;
}

@container field (width<=300px) {

  .item {
    font-size: 20px;
  }
}


@container field (width >=300px) {

  .item {
    font-size: 30px;
  }
}

@container field (width >=400px) {

  .item {
    font-size: 40px;
  }
}

@container field (width >=550px) {

  .item {
    font-size: 60px;
  }
}



.item {
  font-weight: 700;
  display: flex;
  justify-content: center;
  align-items: center;
  border-radius: 5px;
  aspect-ratio: 1 / 1;
  color: #776e65;
}

.item2 {
  background-color: #eee4da;
  color: #776e65;
}

.item4 {
  background-color: #ede0c8;
  color: #776e65;
}

.item8 {
  background-color: #f2b179;
  color: #f9f6f2;
}

.item16 {
  background-color: #f59563;
  color: #f9f6f2;
}

.item32 {
  background-color: #f67c5f;
  color: #f9f6f2;
}

.item64 {
  background-color: #f65e3b;
  color: #f9f6f2;
}

.item128 {
  background-color: #edcf72;
  color: #f9f6f2;
}

.item256 {
  background-color: #edcc61;
  color: #f9f6f2;
}

.item512 {
  background-color: #edc850;
  color: #f9f6f2;
}

.item1024 {
  background-color: #edc53f;
  color: #f9f6f2;
}

.item2048 {
  background-color: #edc22e;
  color: #f9f6f2;
}


// === ./src/2048/components/score/score.module.css ===
.scoreContainer {
  width: 100%;
  display: flex;
  justify-content: space-between;
  container: score / inline-size;
}


@container score (width<=300px) {

  .score {
    font-size: 16px;
  }
}


@container score (width >=300px) {

  .score {
    font-size: 30px;
  }
}

@container score (width >=400px) {

  .score {
    font-size: 40px;
  }
}

@container score (width >=550px) {

  .score {
    font-size: 60px;
  }
}


